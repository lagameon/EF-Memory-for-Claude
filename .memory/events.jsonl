{"id": "lesson-efm_autostart-b52cad04", "type": "lesson", "classification": "hard", "severity": "S2", "title": "EF Memory has no auto-startup: Claude Code sessions start without memory awareness", "content": ["Claude Code has 3 auto-load hooks: CLAUDE.md (project root), .claude/rules/*.md, .claude/settings.local.json", "EF Memory currently uses NONE of these for session startup — no CLAUDE.md exists in the project", ".claude/commands/*.md only loads on explicit /command invocation, not at session start", ".claude/rules/ef-memory/*.md auto-loads IF generated, but generation itself is manual (generate_rules_cli.py)", "Result: users must manually remember to run /memory-search, pipeline_cli.py --startup, etc. each session"], "rule": "EF Memory MUST create a project-level CLAUDE.md to enable auto-awareness at session start", "implication": "Without auto-startup, memory system is invisible to Claude — users who forget to invoke commands get zero benefit from the memory system", "verify": "Check if CLAUDE.md exists in project root and references the memory system", "source": ["CHANGELOG.md", "README.md#Security-Boundaries"], "tags": ["auto-startup", "session-lifecycle", "claude-code", "CLAUDE.md", "ux-gap"], "created_at": "2026-02-07T12:39:40Z", "last_verified": null, "deprecated": false, "_meta": {}}
{"id": "fact-efm_injection_tiers-8ace09ce", "type": "fact", "classification": "hard", "severity": "S2", "title": "Claude Code auto-injection has 3 tiers: CLAUDE.md (always), rules/ (always), commands/ (on-demand)", "content": ["Tier 1 — CLAUDE.md in project root: loaded every session, ideal for system-level instructions and startup behavior", "Tier 2 — .claude/rules/*.md: loaded every session as context rules, ideal for Hard memory auto-injection (M3)", "Tier 3 — .claude/commands/*.md: loaded only on /command invocation, used for /memory-save, /memory-search, etc.", "For auto-startup: need Tier 1 (CLAUDE.md) to instruct Claude about memory system existence and session behavior", "For auto-inject: need Tier 2 (rules/) generated from Hard entries via generate_rules_cli.py"], "rule": "Session-level memory awareness MUST use Tier 1 (CLAUDE.md) or Tier 2 (.claude/rules/), NEVER rely on Tier 3 (commands/) alone", "implication": "If only commands/ are used, Claude has zero memory awareness until user explicitly types /memory-search", "verify": "ls -la CLAUDE.md .claude/rules/ef-memory/ — both should exist for full auto-startup", "source": [".claude/rules/", ".claude/commands/", "README.md"], "tags": ["auto-injection", "claude-code", "CLAUDE.md", "rules", "commands", "architecture"], "created_at": "2026-02-07T12:39:40Z", "last_verified": null, "deprecated": false, "_meta": {}}
{"id": "decision-efm_init_claude_md-18972a69", "type": "decision", "classification": "hard", "severity": "S1", "title": "User init should auto-generate CLAUDE.md with memory system instructions for session auto-start", "content": ["When user runs init/setup, EF Memory should generate a CLAUDE.md that tells Claude about the memory system", "CLAUDE.md should instruct: (1) run startup health check, (2) use /memory-search for relevant context, (3) suggest /memory-save after tasks", "This bridges the gap between having memory infrastructure and actually using it automatically", "Must respect human_review_required toggle — CLAUDE.md behavior should be conditional on config"], "rule": "EF Memory init MUST generate a project CLAUDE.md that enables session-level memory auto-awareness", "implication": "Without this, the entire V2 infrastructure (407 tests, 6 milestones) provides zero value unless users manually invoke commands every session", "verify": "After init: cat CLAUDE.md | grep -i \"memory\" — should reference EF Memory system", "source": ["CONTRIBUTING.md", ".memory/config.json"], "tags": ["init", "CLAUDE.md", "auto-startup", "session-lifecycle", "ux", "critical-gap"], "created_at": "2026-02-07T12:39:40Z", "last_verified": null, "deprecated": false, "_meta": {}}
{"id": "decision-pwf_integration-505a06e0", "type": "decision", "classification": "hard", "severity": "S1", "title": "Planning with Files is short-term working memory; EF Memory is long-term project memory — complementary not competing", "content": ["Planning with Files (PWF) solves intra-session context drift via 3 markdown files: task_plan.md, findings.md, progress.md", "EF Memory solves cross-session knowledge loss via structured JSONL with evidence-first schema", "PWF uses PreToolUse hooks to force-read task_plan.md before every tool call — keeps plan in attention window", "EF Memory uses .claude/rules/ for Hard rule auto-injection and /memory-search for Soft entry retrieval", "Integration path: PWF handles session-level planning, EF Memory handles project-level knowledge persistence"], "rule": "EF Memory and Planning with Files MUST be integrated as complementary layers, not replacements for each other", "implication": "Without integration, users choose one or the other and lose either short-term planning discipline or long-term knowledge retention", "verify": null, "source": ["https://github.com/OthmanAdi/planning-with-files", "README.md"], "tags": ["planning-with-files", "integration", "architecture", "working-memory", "long-term-memory"], "created_at": "2026-02-07T12:55:02Z", "last_verified": null, "deprecated": false, "_meta": {}}
{"id": "decision-pwf_efm_integration_points-b7b55529", "type": "decision", "classification": "hard", "severity": "S1", "title": "Three integration points between PWF and EF Memory: startup prefill, completion harvest, hook fusion", "content": ["Integration Point 1 — Startup Prefill: on session start, inject EF Memory Hard rules + relevant Soft entries into findings.md so PWF starts with project context", "Integration Point 2 — Completion Harvest: when task completes (all phases done), auto-extract lessons/decisions from findings.md and progress.md as /memory-save candidates", "Integration Point 3 — Hook Fusion: PWF PreToolUse hook reads task_plan.md; extend to also surface relevant EF Memory entries for the current task domain", "PWF Stop hook (check-complete.sh) can trigger memory harvest prompt when all phases are marked complete"], "rule": "EF Memory init MUST support PWF integration by providing hooks for startup prefill and completion harvest", "implication": "Without these integration points, PWF findings are lost when the task ends — valuable lessons never make it to long-term memory", "verify": null, "source": ["https://github.com/OthmanAdi/planning-with-files", ".memory/config.json"], "tags": ["planning-with-files", "integration", "hooks", "startup", "harvest", "automation"], "created_at": "2026-02-07T12:55:02Z", "last_verified": null, "deprecated": false, "_meta": {}}
{"id": "fact-pwf_hooks-554210e9", "type": "fact", "classification": "soft", "severity": "S2", "title": "PWF uses SKILL.md frontmatter hooks: PreToolUse cats task_plan.md, PostToolUse reminds update, Stop checks completion", "content": ["PreToolUse hook (matcher: Write|Edit|Bash|Read|Glob|Grep): runs cat task_plan.md | head -30 before every matched tool call", "PostToolUse hook (matcher: Write|Edit): echoes reminder to update task_plan.md after file modifications", "Stop hook: runs check-complete.sh to report phase completion status when Claude stops", "Session recovery: session-catchup.py scans previous session JSONL files for unsynced planning file updates", "Hook mechanism is defined in SKILL.md YAML frontmatter — Claude Code parses these as plugin/skill hooks"], "rule": null, "implication": "The PreToolUse hook is the key innovation — forces plan re-reading into attention window, preventing context drift", "verify": null, "source": ["https://github.com/OthmanAdi/planning-with-files/skills/planning-with-files/SKILL.md"], "tags": ["planning-with-files", "hooks", "PreToolUse", "PostToolUse", "Stop", "session-recovery"], "created_at": "2026-02-07T12:55:02Z", "last_verified": null, "deprecated": false, "_meta": {}}
